from collections import Counter

import numpy as np
from pathlib import Path
from PIL import Image
from scipy import ndimage as ndi
from scipy import stats
import imutils
import glob

def print_image_info(img):
    """Utility to find and print max value of an image (2D numpy array) and its location"""
    assert len(img.shape) == 2
    prefix = " " * 4
    print("Image information")

    max_value = np.max(img)
    max_location_temp = np.where(img == max_value)
    max_location = (max_location_temp[0][0], max_location_temp[1][0])
    print(f"{prefix}Max: {max_value}, First Location: {max_location}")

    min_value = np.min(img)
    min_location_temp = np.where(img == min_value)
    min_location = (min_location_temp[0][0], min_location_temp[1][0])
    print(f"{prefix}Min: {min_value}, First Location: {min_location}")

    s = stats.describe(img.flatten())
    print(f"{prefix}mean, stdev: {s.mean}, {np.sqrt(s.variance)}")


def print_image_stats(img, msg=""):
    """Assumes a 2D numpy array."""
    s = stats.describe(img.flatten())
    print(f"{msg}")
    print(f"min, max: {s.minmax}")
    print(f"mean, stdev: {s.mean}, {np.sqrt(s.variance)}")
    return s


def load_image_as_numpy_array(file):
    """Self explanatory.

    Args:
        file (Path object): Path of file

    Returns:
        2D numpy array: image
    """
    return np.array(Image.open(file))


def load_images(list_of_image_files, max_float_value):
    """Load images from list of image files, which must be Path objects.

    Arguments
    ---------
    list_of_image_files (list of Path objects)

    Returns
    -------
    List of loaded images. Pixels are floats scaled so that a graylevel of 255
    is 1.0.
    """

    images = []
    for image_file in list_of_image_files:
        images.append(img_as_float(load_image_as_numpy_array(image_file), max_float_value))

    return images


def img_as_float(image, max_possible_value=255):
    """Convert image pixel type to float. Normalize by max_possible_value."""
    return image.astype(float) / max_possible_value


def make_average_image(list_of_images):
    """Create an average image from a list of images."""
    for i, image in enumerate(list_of_images):
        if i == 0:
            temp_image = image.copy()
        else:
            temp_image += image
    return temp_image / len(list_of_images)

def normalize_image(image):
    return image/np.max(image)

def save_normalized_irradiance_image_as_png(file, image, dtype="uint8"):
    """Save interpolated image as 8 bit or 16 bit png image, which reduces
    file size (104 kB and 1.2 MB, respectively).
    """
    assert isinstance(file, Path)
    assert file.name.endswith(".png")
    assert dtype in ["uint8", "uint16", "uint32"]

    if dtype == "uint8":
        temp_img = (image * 255.0).astype("uint8")
    elif dtype in ["uint16", "uint32"]:
        temp_img = (image * 65535.0).astype("uint16")
    Image.fromarray(temp_img).save(file)


def save_normalized_irradiance_image_as_npy(file, image):
    """Save full precision of interpolated image, but results in large
    (33 MB) binary file.
    """
    assert isinstance(file, Path)
    assert file.name.endswith(".npy")

    np.save(file, image)

def correct_image(correction_image, image):
    return image/correction_image


def correct_for_irradiance_nonuniformity(
    img, correction_img, max_value=255, value_type="uint8"
):
    """Returns image that has been corrected for the irradiance
    nonuniformity in one of our 3D printers.

    Arguments
    ---------
    img: 2d numpy array
        Grayscale image to be corrected
    correction_img: 2d numpy array
        Grayscale image of the irradiance nonuniformity, usually
        generated by 2D interpolation from measured data
    max_value: int, float
        Maximum value the corrected image should have
    value_type: str, numpy.dtype
        Variable type the pixels should have for the returned imge

    Returns
    -------
    2d numpy array

    Example Usage
    -------------
    # Returns an 8-bit image with values in the range [0-255]
    corrected_image = correct_for_irradiance_nonuniformity(
        original_image, correction_image)

    # Returns a float image with values in the range [0.0-1.0]
    corrected_image = correct_for_irradiance_nonuniformity(original_image,
        correction_image, max_value=1.0, value_type='float')
    """
    assert img.shape == correction_img.shape
    temp = img / correction_img
    return (temp * max_value / np.max(temp)).astype(value_type)






print("list images")
images_names = glob.glob('flats/*.png')
print(images_names)

print("print info")
single_image = load_image_as_numpy_array(images_names[0])
print_image_info(single_image)
print_image_stats(single_image)

print("load images")
images = load_images(images_names, 65535)

print("make average image")
average_image = make_average_image(images)

print("normalize image")
average_image_normalized = normalize_image(average_image)

print("save image")
save_normalized_irradiance_image_as_png(Path("average.png"), average_image)
save_normalized_irradiance_image_as_npy(Path("average.npy"), average_image)
save_normalized_irradiance_image_as_png(Path("average_normalized.png"), average_image_normalized)
save_normalized_irradiance_image_as_npy(Path("average_normalized.npy"), average_image_normalized)

print("test flat correction")
correction_img = np.load("average_normalized.npy")
images_names = glob.glob('test_images/*.png')
for i in images_names:
    img_data = np.array(Image.open(i))
    print_image_stats(img_data)
    corrected_image = correct_for_irradiance_nonuniformity(img_data, correction_img)
    print_image_stats(corrected_image)
    Image.fromarray(corrected_image, "L").save(
        f"{i}_corrected.png", "PNG"
    )
